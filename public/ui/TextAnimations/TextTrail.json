{"name":"TextAnimations/TextTrail","type":"TextAnimations","add":"when-added","files":[{"type":"TextAnimations","role":"file","content":"<script setup lang=\"ts\">\nimport { ref, onMounted, onUnmounted, watch, useTemplateRef } from 'vue';\nimport {\n  CanvasTexture,\n  Clock,\n  Color,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  Mesh,\n  OrthographicCamera,\n  PlaneGeometry,\n  Scene,\n  ShaderMaterial,\n  Vector2,\n  Vector3,\n  WebGLRenderer,\n  WebGLRenderTarget\n} from 'three';\n\ninterface TextTrailProps {\n  text?: string;\n  fontFamily?: string;\n  fontWeight?: string | number;\n  noiseFactor?: number;\n  noiseScale?: number;\n  rgbPersistFactor?: number;\n  alphaPersistFactor?: number;\n  animateColor?: boolean;\n  startColor?: string;\n  textColor?: string;\n  backgroundColor?: number | string;\n  colorCycleInterval?: number;\n  supersample?: number;\n}\n\nconst props = withDefaults(defineProps<TextTrailProps>(), {\n  text: 'Vibe',\n  fontFamily: 'Figtree',\n  fontWeight: '900',\n  noiseFactor: 1,\n  noiseScale: 0.0005,\n  rgbPersistFactor: 0.98,\n  alphaPersistFactor: 0.95,\n  animateColor: false,\n  startColor: '#ffffff',\n  textColor: '#ffffff',\n  backgroundColor: 0x151515,\n  colorCycleInterval: 3000,\n  supersample: 2\n});\n\nconst containerRef = useTemplateRef<HTMLDivElement>('containerRef');\n\nconst hexToRgb = (hex: string): [number, number, number] => {\n  let h = hex.replace('#', '');\n  if (h.length === 3)\n    h = h\n      .split('')\n      .map(c => c + c)\n      .join('');\n  const n = parseInt(h, 16);\n  return [(n >> 16) & 255, (n >> 8) & 255, n & 255];\n};\n\nconst loadFont = async (fam: string) => {\n  if ('fonts' in document) {\n    const fonts = (document as Document & { fonts: { load: (font: string) => Promise<void> } }).fonts;\n    await fonts.load(`64px \"${fam}\"`);\n  }\n};\n\nconst BASE_VERT = `\nvarying vec2 v_uv;\nvoid main(){gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);v_uv=uv;}`;\n\nconst SIMPLEX = `\nvec3 mod289(vec3 x){return x-floor(x*(1./289.))*289.;}\nvec4 mod289(vec4 x){return x-floor(x*(1./289.))*289.;}\nvec4 permute(vec4 x){return mod289(((x*34.)+1.)*x);}\nfloat snoise3(vec3 v){\n  const vec2 C=vec2(1./6.,1./3.);\n  const vec4 D=vec4(0.,.5,1.,2.);\n  vec3 i=floor(v+dot(v,C.yyy));\n  vec3 x0=v-i+dot(i,C.xxx);\n  vec3 g=step(x0.yzx,x0.xyz);\n  vec3 l=1.-g;\n  vec3 i1=min(g.xyz,l.zxy);\n  vec3 i2=max(g.xyz,l.zxy);\n  vec3 x1=x0-i1+C.xxx;\n  vec3 x2=x0-i2+C.yyy;\n  vec3 x3=x0-D.yyy;\n  i=mod289(i);\n  vec4 p=permute(permute(permute(i.z+vec4(0.,i1.z,i2.z,1.))+i.y+vec4(0.,i1.y,i2.y,1.))+i.x+vec4(0.,i1.x,i2.x,1.));\n  float n_=1./7.; vec3 ns=n_*D.wyz-D.xzx;\n  vec4 j=p-49.*floor(p*ns.z*ns.z);\n  vec4 x_=floor(j*ns.z);\n  vec4 y_=floor(j-7.*x_);\n  vec4 x=x_*ns.x+ns.yyyy;\n  vec4 y=y_*ns.x+ns.yyyy;\n  vec4 h=1.-abs(x)-abs(y);\n  vec4 b0=vec4(x.xy,y.xy);\n  vec4 b1=vec4(x.zw,y.zw);\n  vec4 s0=floor(b0)*2.+1.;\n  vec4 s1=floor(b1)*2.+1.;\n  vec4 sh=-step(h,vec4(0.));\n  vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;\n  vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;\n  vec3 p0=vec3(a0.xy,h.x);\n  vec3 p1=vec3(a0.zw,h.y);\n  vec3 p2=vec3(a1.xy,h.z);\n  vec3 p3=vec3(a1.zw,h.w);\n  vec4 norm=inversesqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));\n  p0*=norm.x; p1*=norm.y; p2*=norm.z; p3*=norm.w;\n  vec4 m=max(.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.);\n  m*=m;\n  return 42.*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));\n}`;\n\nconst PERSIST_FRAG = `\nuniform sampler2D sampler;\nuniform float time;\nuniform vec2 mousePos;\nuniform float noiseFactor,noiseScale,rgbPersistFactor,alphaPersistFactor;\nvarying vec2 v_uv;\n${SIMPLEX}\nvoid main(){\n  float a=snoise3(vec3(v_uv*noiseFactor,time*.1))*noiseScale;\n  float b=snoise3(vec3(v_uv*noiseFactor,time*.1+100.))*noiseScale;\n  vec4 t=texture2D(sampler,v_uv+vec2(a,b)+mousePos*.005);\n  gl_FragColor=vec4(t.xyz*rgbPersistFactor,alphaPersistFactor);\n}`;\n\nconst TEXT_FRAG = `\nuniform sampler2D sampler;uniform vec3 color;varying vec2 v_uv;\nvoid main(){\n  vec4 t=texture2D(sampler,v_uv);\n  float alpha=smoothstep(0.1,0.9,t.a);\n  if(alpha<0.01)discard;\n  gl_FragColor=vec4(color,alpha);\n}`;\n\nlet renderer: WebGLRenderer | null = null;\nlet scene: Scene | null = null;\nlet fluidScene: Scene | null = null;\nlet clock: Clock | null = null;\nlet cam: OrthographicCamera | null = null;\nlet rt0: WebGLRenderTarget | null = null;\nlet rt1: WebGLRenderTarget | null = null;\nlet quadMat: ShaderMaterial | null = null;\nlet quad: Mesh | null = null;\nlet labelMat: ShaderMaterial | null = null;\nlet label: Mesh | null = null;\nlet resizeObserver: ResizeObserver | null = null;\nlet colorTimer: number | null = null;\n\nconst persistColor = ref<[number, number, number]>(\n  hexToRgb(props.textColor || props.startColor).map(c => c / 255) as [number, number, number]\n);\nconst targetColor = ref<[number, number, number]>([...persistColor.value]);\n\nconst mouse = [0, 0];\nconst target = [0, 0];\n\nconst getSize = () => ({\n  w: containerRef.value!.clientWidth,\n  h: containerRef.value!.clientHeight\n});\n\nconst onMove = (e: PointerEvent) => {\n  if (!containerRef.value) return;\n  const r = containerRef.value.getBoundingClientRect();\n  target[0] = ((e.clientX - r.left) / r.width) * 2 - 1;\n  target[1] = ((r.top + r.height - e.clientY) / r.height) * 2 - 1;\n};\n\nconst drawText = () => {\n  if (!renderer || !labelMat) return;\n\n  const texCanvas = document.createElement('canvas');\n  const ctx = texCanvas.getContext('2d', {\n    alpha: true,\n    colorSpace: 'srgb'\n  })!;\n\n  const max = Math.min(renderer.capabilities.maxTextureSize, 4096);\n  const pixelRatio = (window.devicePixelRatio || 1) * props.supersample;\n  const canvasSize = max * pixelRatio;\n  texCanvas.width = canvasSize;\n  texCanvas.height = canvasSize;\n  texCanvas.style.width = `${max}px`;\n  texCanvas.style.height = `${max}px`;\n\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\n  ctx.scale(pixelRatio, pixelRatio);\n  ctx.clearRect(0, 0, max, max);\n  ctx.imageSmoothingEnabled = true;\n  ctx.imageSmoothingQuality = 'high';\n  ctx.shadowColor = 'rgba(255,255,255,0.3)';\n  ctx.shadowBlur = 2;\n  ctx.fillStyle = '#fff';\n  ctx.textAlign = 'center';\n  ctx.textBaseline = 'middle';\n\n  const refSize = 250;\n  ctx.font = `${props.fontWeight} ${refSize}px ${props.fontFamily}`;\n  const width = ctx.measureText(props.text).width;\n  ctx.font = `${props.fontWeight} ${(refSize * max) / width}px ${props.fontFamily}`;\n\n  const cx = max / 2;\n  const cy = max / 2;\n  const offs = [\n    [0, 0],\n    [0.1, 0],\n    [-0.1, 0],\n    [0, 0.1],\n    [0, -0.1],\n    [0.1, 0.1],\n    [-0.1, -0.1],\n    [0.1, -0.1],\n    [-0.1, 0.1]\n  ];\n  ctx.globalAlpha = 1 / offs.length;\n  offs.forEach(([dx, dy]) => ctx.fillText(props.text, cx + dx, cy + dy));\n  ctx.globalAlpha = 1;\n\n  const tex = new CanvasTexture(texCanvas);\n  tex.generateMipmaps = true;\n  tex.minFilter = LinearMipmapLinearFilter;\n  tex.magFilter = LinearFilter;\n  labelMat.uniforms.sampler.value = tex;\n};\n\nconst initThreeJS = async () => {\n  if (!containerRef.value) return;\n\n  let { w, h } = getSize();\n\n  renderer = new WebGLRenderer({ antialias: true });\n  renderer.setClearColor(\n    typeof props.backgroundColor === 'string' ? new Color(props.backgroundColor) : new Color(props.backgroundColor),\n    1\n  );\n  renderer.setPixelRatio(window.devicePixelRatio || 1);\n  renderer.setSize(w, h);\n  containerRef.value.appendChild(renderer.domElement);\n\n  scene = new Scene();\n  fluidScene = new Scene();\n  clock = new Clock();\n  cam = new OrthographicCamera(-w / 2, w / 2, h / 2, -h / 2, 0.1, 10);\n  cam.position.z = 1;\n\n  rt0 = new WebGLRenderTarget(w, h);\n  rt1 = rt0.clone();\n\n  quadMat = new ShaderMaterial({\n    uniforms: {\n      sampler: { value: null },\n      time: { value: 0 },\n      mousePos: { value: new Vector2(-1, 1) },\n      noiseFactor: { value: props.noiseFactor },\n      noiseScale: { value: props.noiseScale },\n      rgbPersistFactor: { value: props.rgbPersistFactor },\n      alphaPersistFactor: { value: props.alphaPersistFactor }\n    },\n    vertexShader: BASE_VERT,\n    fragmentShader: PERSIST_FRAG,\n    transparent: true\n  });\n  quad = new Mesh(new PlaneGeometry(w, h), quadMat);\n  fluidScene.add(quad);\n\n  labelMat = new ShaderMaterial({\n    uniforms: {\n      sampler: { value: null },\n      color: { value: new Vector3(...persistColor.value) }\n    },\n    vertexShader: BASE_VERT,\n    fragmentShader: TEXT_FRAG,\n    transparent: true\n  });\n  label = new Mesh(new PlaneGeometry(Math.min(w, h), Math.min(w, h)), labelMat);\n  scene.add(label);\n\n  await loadFont(props.fontFamily);\n  drawText();\n\n  containerRef.value.addEventListener('pointermove', onMove);\n\n  resizeObserver = new ResizeObserver(() => {\n    if (!containerRef.value || !renderer || !cam || !quad || !rt0 || !rt1 || !label) return;\n\n    const size = getSize();\n    w = size.w;\n    h = size.h;\n\n    renderer.setSize(w, h);\n    cam.left = -w / 2;\n    cam.right = w / 2;\n    cam.top = h / 2;\n    cam.bottom = -h / 2;\n    cam.updateProjectionMatrix();\n    quad.geometry.dispose();\n    quad.geometry = new PlaneGeometry(w, h);\n    rt0.setSize(w, h);\n    rt1.setSize(w, h);\n    label.geometry.dispose();\n    label.geometry = new PlaneGeometry(Math.min(w, h), Math.min(w, h));\n  });\n  resizeObserver.observe(containerRef.value);\n\n  colorTimer = setInterval(() => {\n    if (!props.textColor) {\n      targetColor.value = [Math.random(), Math.random(), Math.random()];\n    }\n  }, props.colorCycleInterval);\n\n  const animate = () => {\n    if (!renderer || !quadMat || !labelMat || !clock || !scene || !fluidScene || !cam || !rt0 || !rt1) return;\n\n    const dt = clock.getDelta();\n    if (props.animateColor && !props.textColor) {\n      for (let i = 0; i < 3; i++) persistColor.value[i] += (targetColor.value[i] - persistColor.value[i]) * dt;\n    }\n    const speed = dt * 5;\n    mouse[0] += (target[0] - mouse[0]) * speed;\n    mouse[1] += (target[1] - mouse[1]) * speed;\n\n    quadMat.uniforms.mousePos.value.set(mouse[0], mouse[1]);\n    quadMat.uniforms.sampler.value = rt1.texture;\n    quadMat.uniforms.time.value = clock.getElapsedTime();\n    labelMat.uniforms.color.value.set(...persistColor.value);\n\n    renderer.autoClearColor = false;\n    renderer.setRenderTarget(rt0);\n    renderer.clearColor();\n    renderer.render(fluidScene, cam);\n    renderer.render(scene, cam);\n    renderer.setRenderTarget(null);\n    renderer.render(fluidScene, cam);\n    renderer.render(scene, cam);\n    [rt0, rt1] = [rt1, rt0];\n  };\n\n  renderer.setAnimationLoop(animate);\n};\n\nconst cleanup = () => {\n  if (renderer) {\n    renderer.setAnimationLoop(null);\n    if (containerRef.value && renderer.domElement.parentNode === containerRef.value) {\n      containerRef.value.removeChild(renderer.domElement);\n    }\n    renderer.dispose();\n    renderer = null;\n  }\n\n  if (colorTimer) {\n    clearInterval(colorTimer);\n    colorTimer = null;\n  }\n\n  if (containerRef.value) {\n    containerRef.value.removeEventListener('pointermove', onMove);\n  }\n\n  if (resizeObserver) {\n    resizeObserver.disconnect();\n    resizeObserver = null;\n  }\n\n  if (rt0) {\n    rt0.dispose();\n    rt0 = null;\n  }\n\n  if (rt1) {\n    rt1.dispose();\n    rt1 = null;\n  }\n\n  if (quadMat) {\n    quadMat.dispose();\n    quadMat = null;\n  }\n\n  if (quad) {\n    quad.geometry.dispose();\n    quad = null;\n  }\n\n  if (labelMat) {\n    labelMat.dispose();\n    labelMat = null;\n  }\n\n  if (label) {\n    label.geometry.dispose();\n    label = null;\n  }\n\n  scene = null;\n  fluidScene = null;\n  clock = null;\n  cam = null;\n};\n\nwatch(\n  () => [\n    props.text,\n    props.fontFamily,\n    props.fontWeight,\n    props.noiseFactor,\n    props.noiseScale,\n    props.rgbPersistFactor,\n    props.alphaPersistFactor,\n    props.animateColor,\n    props.startColor,\n    props.textColor,\n    props.backgroundColor,\n    props.colorCycleInterval,\n    props.supersample\n  ],\n  () => {\n    cleanup();\n    if (containerRef.value) {\n      persistColor.value = hexToRgb(props.textColor || props.startColor).map(c => c / 255) as [number, number, number];\n      targetColor.value = [...persistColor.value];\n      initThreeJS();\n    }\n  },\n  { deep: true }\n);\n\nonMounted(() => {\n  if (containerRef.value) {\n    initThreeJS();\n  }\n});\n\nonUnmounted(() => {\n  cleanup();\n});\n</script>\n\n<template>\n  <div ref=\"containerRef\" class=\"w-full h-full\" />\n</template>\n","path":"TextTrail/TextTrail.vue","_imports_":[],"registryDependencies":[],"dependencies":[],"devDependencies":[]}],"registryDependencies":[],"dependencies":[{"ecosystem":"js","name":"three","version":"^0.178.0"}],"devDependencies":[]}