{"name":"Components/RollingGallery","type":"Components","add":"when-added","files":[{"type":"Components","role":"file","content":"<template>\n  <div class=\"relative h-[500px] w-full overflow-hidden\">\n    <div class=\"absolute top-0 left-0 h-full w-12 z-10 bg-gradient-to-l from-transparent to-[#0b0b0b]\" />\n    <div class=\"absolute top-0 right-0 h-full w-12 z-10 bg-gradient-to-r from-transparent to-[#0b0b0b]\" />\n\n    <div class=\"flex h-full items-center justify-center [perspective:1000px] [transform-style:preserve-3d]\">\n      <Motion\n        tag=\"div\"\n        class=\"flex min-h-[200px] items-center justify-center w-full cursor-grab select-none will-change-transform [transform-style:preserve-3d] active:cursor-grabbing\"\n        :style=\"trackStyle\"\n        :animate=\"animateProps\"\n        :transition=\"springTransition\"\n        @mouseenter=\"handleMouseEnter\"\n        @mouseleave=\"handleMouseLeave\"\n        @mousedown=\"handleMouseDown\"\n      >\n        <div\n          v-for=\"(url, i) in displayImages\"\n          :key=\"`gallery-${i}`\"\n          :style=\"getItemStyle(i)\"\n          class=\"absolute flex items-center justify-center px-[8%] [backface-visibility:hidden] will-change-transform pointer-events-none\"\n        >\n          <img\n            :src=\"url\"\n            alt=\"gallery\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            class=\"pointer-events-auto h-[120px] w-[300px] rounded-[15px] border-[3px] border-white object-cover transition-transform duration-300 ease-in-out will-change-transform hover:scale-105\"\n          />\n        </div>\n      </Motion>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed, onMounted, onUnmounted, ref, shallowRef, watch } from 'vue';\nimport { Motion } from 'motion-v';\n\ninterface RollingGalleryProps {\n  autoplay?: boolean;\n  pauseOnHover?: boolean;\n  images?: string[];\n}\n\nconst props = withDefaults(defineProps<RollingGalleryProps>(), {\n  autoplay: false,\n  pauseOnHover: false,\n  images: () => []\n});\n\nconst DEFAULT_IMAGES = shallowRef([\n  'https://images.unsplash.com/photo-1528181304800-259b08848526?q=80&w=3870&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',\n  'https://images.unsplash.com/photo-1506665531195-3566af2b4dfa?q=80&w=3870&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',\n  'https://images.unsplash.com/photo-1520250497591-112f2f40a3f4?q=80&w=3456&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',\n  'https://images.unsplash.com/photo-1495103033382-fe343886b671?q=80&w=3870&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',\n  'https://images.unsplash.com/photo-1506781961370-37a89d6b3095?q=80&w=3264&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',\n  'https://images.unsplash.com/photo-1599576838688-8a6c11263108?q=80&w=3870&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',\n  'https://images.unsplash.com/photo-1494094892896-7f14a4433b7a?q=80&w=3870&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',\n  'https://plus.unsplash.com/premium_photo-1664910706524-e783eed89e71?q=80&w=3869&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',\n  'https://images.unsplash.com/photo-1503788311183-fa3bf9c4bc32?q=80&w=3870&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D',\n  'https://images.unsplash.com/photo-1585970480901-90d6bb2a48b5?q=80&w=3774&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D'\n]);\n\nconst isScreenSizeSm = ref(false);\nconst rotateYValue = ref(0);\nconst autoplayInterval = ref<number | null>(null);\nconst autoplayTimeout = ref<number | null>(null);\nconst isDragging = ref(false);\nconst isHovered = ref(false);\nconst dragStartX = ref(0);\nconst dragStartRotation = ref(0);\n\nconst displayImages = computed(() => {\n  const sourceImages = props.images.length > 0 ? props.images : DEFAULT_IMAGES.value;\n  const maxImages = REFERENCE_FACE_COUNT_SPACING;\n\n  if (sourceImages.length >= maxImages) {\n    return sourceImages;\n  }\n\n  const repeatedImages = [];\n  const repetitions = Math.ceil(maxImages / sourceImages.length);\n\n  for (let i = 0; i < repetitions; i++) {\n    repeatedImages.push(...sourceImages);\n  }\n\n  return repeatedImages.slice(0, maxImages);\n});\n\nconst cylinderWidth = computed(() => (isScreenSizeSm.value ? 1100 : 1800));\nconst faceWidth = computed(() => {\n  return (cylinderWidth.value / REFERENCE_FACE_COUNT_SIZING) * 1.5;\n});\nconst radius = computed(() => cylinderWidth.value / (2 * Math.PI));\n\nconst DRAG_FACTOR = Object.freeze(0.15);\nconst MOMENTUM_FACTOR = Object.freeze(0.05);\nconst AUTOPLAY_INTERVAL = Object.freeze(2000);\nconst DRAG_RESTART_DELAY = Object.freeze(1500);\nconst HOVER_RESTART_DELAY = Object.freeze(100);\nconst HOVER_DEBOUNCE_DELAY = Object.freeze(50);\nconst REFERENCE_FACE_COUNT_SPACING = Object.freeze(10);\nconst REFERENCE_FACE_COUNT_SIZING = Object.freeze(10);\n\nconst trackStyle = computed(() => ({\n  width: `${cylinderWidth.value}px`,\n  transformStyle: 'preserve-3d' as const\n}));\n\nconst animateProps = computed(() => ({\n  rotateY: rotateYValue.value\n}));\n\nconst springTransition = computed(() => {\n  if (isDragging.value) {\n    return { duration: 0 };\n  } else {\n    return {\n      duration: 0.8,\n      ease: 'easeOut' as const\n    };\n  }\n});\n\nconst styleCache = new Map<string, { width: string; transform: string }>();\n\nconst getItemStyle = (index: number) => {\n  const cacheKey = `${index}-${faceWidth.value}-${radius.value}`;\n\n  if (styleCache.has(cacheKey)) {\n    return styleCache.get(cacheKey)!;\n  }\n\n  const style = {\n    width: `${faceWidth.value}px`,\n    transform: `rotateY(${index * (360 / REFERENCE_FACE_COUNT_SPACING)}deg) translateZ(${radius.value}px)`\n  };\n\n  if (styleCache.size > 50) {\n    styleCache.clear();\n  }\n\n  styleCache.set(cacheKey, style);\n  return style;\n};\n\nlet resizeTimeout: number | null = null;\nlet hoverTimeout: number | null = null;\n\nfunction checkScreenSize() {\n  isScreenSizeSm.value = window.innerWidth <= 640;\n}\n\nfunction throttledResize() {\n  if (resizeTimeout) return;\n  resizeTimeout = setTimeout(() => {\n    checkScreenSize();\n    resizeTimeout = null;\n  }, 100);\n}\n\nfunction handleMouseDown(event: MouseEvent) {\n  isDragging.value = true;\n  dragStartX.value = event.clientX;\n  dragStartRotation.value = rotateYValue.value;\n\n  stopAutoplay();\n\n  document.addEventListener('mousemove', handleMouseMove, { passive: true });\n  document.addEventListener('mouseup', handleMouseUp, { passive: true });\n  event.preventDefault();\n}\n\nfunction handleMouseMove(event: MouseEvent) {\n  if (!isDragging.value) return;\n\n  const deltaX = event.clientX - dragStartX.value;\n  const rotationDelta = deltaX * DRAG_FACTOR;\n  rotateYValue.value = dragStartRotation.value + rotationDelta;\n}\n\nfunction handleMouseUp(event: MouseEvent) {\n  if (!isDragging.value) return;\n\n  isDragging.value = false;\n\n  const deltaX = event.clientX - dragStartX.value;\n  const velocity = deltaX * MOMENTUM_FACTOR;\n  rotateYValue.value += velocity;\n\n  document.removeEventListener('mousemove', handleMouseMove);\n  document.removeEventListener('mouseup', handleMouseUp);\n\n  stopAutoplay();\n\n  if (props.autoplay) {\n    if (props.pauseOnHover && isHovered.value) {\n      return;\n    } else {\n      autoplayTimeout.value = setTimeout(() => {\n        if (!isDragging.value && (!props.pauseOnHover || !isHovered.value)) {\n          startAutoplay();\n        }\n      }, DRAG_RESTART_DELAY);\n    }\n  }\n}\n\nfunction startAutoplay() {\n  if (!props.autoplay || isDragging.value || (props.pauseOnHover && isHovered.value)) return;\n\n  stopAutoplay();\n\n  autoplayInterval.value = setInterval(() => {\n    if (!isDragging.value && (!props.pauseOnHover || !isHovered.value)) {\n      rotateYValue.value -= 360 / REFERENCE_FACE_COUNT_SPACING;\n    }\n  }, AUTOPLAY_INTERVAL);\n}\n\nfunction stopAutoplay() {\n  if (autoplayInterval.value) {\n    clearInterval(autoplayInterval.value);\n    autoplayInterval.value = null;\n  }\n  if (autoplayTimeout.value) {\n    clearTimeout(autoplayTimeout.value);\n    autoplayTimeout.value = null;\n  }\n}\n\nfunction handleMouseEnter() {\n  if (hoverTimeout) {\n    clearTimeout(hoverTimeout);\n    hoverTimeout = null;\n  }\n\n  hoverTimeout = setTimeout(() => {\n    isHovered.value = true;\n\n    if (props.autoplay && props.pauseOnHover && !isDragging.value) {\n      stopAutoplay();\n    }\n  }, HOVER_DEBOUNCE_DELAY);\n}\n\nfunction handleMouseLeave() {\n  if (hoverTimeout) {\n    clearTimeout(hoverTimeout);\n    hoverTimeout = null;\n  }\n\n  hoverTimeout = setTimeout(() => {\n    isHovered.value = false;\n\n    if (props.autoplay && props.pauseOnHover && !isDragging.value) {\n      stopAutoplay();\n      autoplayTimeout.value = setTimeout(() => {\n        if (props.autoplay && !isDragging.value && !isHovered.value) {\n          startAutoplay();\n        }\n      }, HOVER_RESTART_DELAY);\n    }\n  }, HOVER_DEBOUNCE_DELAY);\n}\n\nonMounted(() => {\n  checkScreenSize();\n  window.addEventListener('resize', throttledResize, { passive: true });\n\n  if (props.autoplay) {\n    startAutoplay();\n  }\n});\n\nonUnmounted(() => {\n  window.removeEventListener('resize', throttledResize);\n  document.removeEventListener('mousemove', handleMouseMove);\n  document.removeEventListener('mouseup', handleMouseUp);\n  stopAutoplay();\n  if (resizeTimeout) {\n    clearTimeout(resizeTimeout);\n  }\n  if (hoverTimeout) {\n    clearTimeout(hoverTimeout);\n    hoverTimeout = null;\n  }\n});\n\nwatch(\n  () => props.autoplay,\n  newVal => {\n    stopAutoplay();\n    if (newVal && !isDragging.value && (!props.pauseOnHover || !isHovered.value)) {\n      autoplayTimeout.value = setTimeout(() => {\n        if (!isDragging.value && (!props.pauseOnHover || !isHovered.value)) {\n          startAutoplay();\n        }\n      }, HOVER_RESTART_DELAY);\n    }\n  }\n);\n\nwatch(\n  () => props.pauseOnHover,\n  () => {\n    if (props.autoplay) {\n      stopAutoplay();\n      if (!isDragging.value && (!props.pauseOnHover || !isHovered.value)) {\n        startAutoplay();\n      }\n    }\n  }\n);\n</script>\n","path":"RollingGallery/RollingGallery.vue","_imports_":[],"registryDependencies":[],"dependencies":[],"devDependencies":[]}],"registryDependencies":[],"dependencies":[{"ecosystem":"js","name":"motion-v","version":"^1.5.0"}],"devDependencies":[]}